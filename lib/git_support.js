// Generated by CoffeeScript 1.4.0
var Shell, defer, fs, git, mkdirp, nodefn, sequence;

Shell = require('./shell');

fs = require('fs');

sequence = require('when/sequence');

nodefn = require('when/node/function');

defer = require('when').defer;

mkdirp = require('fs-extra').mkdirp;

module.exports = git = {
  getConfigItem: function(repo, configItem, callback) {
    var gitDir;
    gitDir = "" + repo.workDir + "/.git";
    try {
      return Shell.spawn('git', ["--git-dir=" + gitDir, 'config', '--get', configItem], null, function(error, result) {
        if (error) {
          return callback(error);
        }
        repo[configItem] = result.stdout.trim();
        return callback(null, repo);
      });
    } catch (error) {
      return callback(error);
    }
  },
  getHEAD: function(repo, callback) {
    var gitDir;
    gitDir = "" + repo.workDir + "/.git";
    return fs.readFile("" + gitDir + "/HEAD", function(error, data) {
      if (error) {
        return callback(error);
      }
      try {
        repo.HEAD = data.toString().match(/ref: (.*)\n$/)[1];
      } catch (error) {
        return callback(error);
      }
      return callback(null, repo);
    });
  },
  getVersion: function(repo, ref, callback) {
    var gitDir;
    gitDir = "" + repo.workDir + "/.git";
    return fs.readFile("" + gitDir + "/" + ref, function(error, data) {
      if (error) {
        return callback(error);
      }
      repo.version = data.toString().trim();
      return callback(null, repo);
    });
  },
  getStatus: function(workDir, callback) {
    var gitDir;
    gitDir = git.gitDir(workDir);
    return Shell.spawn('git', ["--git-dir=" + gitDir, "--work-tree=" + workDir, 'status'], null, callback);
  },
  checkoutArgs: function(workDir, branch) {
    return ["--git-dir=" + workDir + "/.git", "--work-tree=" + workDir, 'checkout', branch.replace('refs/heads/', '')];
  },
  needClone: function(workDir, callback) {
    var gitDir;
    gitDir = git.gitDir(workDir);
    if (Shell.gotDirectory(gitDir)) {
      callback('already cloned');
      return;
    }
    return callback(null, {
      pre_checks: {
        missing_repo: true
      }
    });
  },
  missingRepo: function(workDir, callback) {
    var gitDir;
    gitDir = git.gitDir(workDir);
    if (!Shell.gotDirectory(gitDir)) {
      callback('missing repo');
      return;
    }
    return callback(null, {
      pre_checks: {
        missing_repo: false
      }
    });
  },
  wrongBranch: function(workDir, branch, callback) {
    return git.getHeadRef(workDir, function(error, headRef) {
      if (headRef !== branch) {
        return callback('wrong branch');
      }
      return callback(null, {
        pre_checks: {
          wrong_branch: false
        }
      });
    });
  },
  getStagedChanges: function(workDir, callback) {
    return Shell.spawn('git', ["--git-dir=" + workDir + "/.git", "--work-tree=" + workDir, 'diff', '--cached'], null, callback);
  },
  noStagedChanges: function(workDir, callback) {
    return git.getStagedChanges(workDir, function(error, result) {
      if (result.stdout === '') {
        return callback('nothing staged');
      }
      return callback(null);
    });
  },
  status: function(workDir, origin, branch, superTask, callback) {
    return sequence([
      function() {
        return nodefn.call(git.missingRepo, workDir);
      }, function() {
        return nodefn.call(git.wrongBranch, workDir, branch);
      }, function() {
        return nodefn.call(git.getStatus, workDir);
      }
    ]).then(function(resultArray) {
      var status;
      console.log('STATUS RESULTS', resultArray);
      status = resultArray[2];
      if (status.stdout.match(/branch is ahead/)) {
        superTask.notify.info.bad('unpushed', {
          description: workDir,
          detail: status.stdout
        });
        return callback(null, resultArray);
      }
      if (status.stdout.match(/nothing to commit \(working directory clean\)/)) {
        superTask.notify.info.normal('unchanged', workDir);
        return callback(null, resultArray);
      }
      superTask.notify.info.good('changed', {
        description: workDir,
        detail: status.stdout
      });
      return callback(null, resultArray);
    }, function(error) {
      if (error === 'missing repo') {
        superTask.notify.info.bad('missing repo', workDir);
        callback(null, {});
        return;
      }
      if (error === 'wrong branch') {
        superTask.notify.info.bad('wrong branch', "" + workDir + " - expects " + branch);
        callback(null, {});
        return;
      }
      return callback(error);
    });
  },
  clone: function(workDir, origin, branch, superTask, callback) {
    var cloneArgs;
    cloneArgs = ['clone', origin, workDir];
    console.log('TODO: report on mkdirp');
    return sequence([
      function() {
        return nodefn.call(mkdirp, workDir);
      }, function() {
        return nodefn.call(git.needClone, workDir);
      }, function() {
        return nodefn.call(Shell.spawn, 'git', ['clone', origin, workDir], superTask);
      }, function() {
        return nodefn.call(Shell.spawn, 'git', git.checkoutArgs(workDir, branch), superTask);
      }
    ]).then(function(resultArray) {
      return callback(null, resultArray);
    }, function(error) {
      if (error !== 'already cloned') {
        return callback(error);
      }
      superTask.notify.info.good('already cloned', workDir);
      return callback(null, {});
    });
  },
  commitArgs: function(workDir, logMessage) {
    return ["--git-dir=" + workDir + "/.git", "--work-tree=" + workDir, 'commit', '-m', logMessage];
  },
  commit: function(workDir, origin, branch, logMessage, superTask, callback) {
    return sequence([
      function() {
        return nodefn.call(git.missingRepo, workDir);
      }, function() {
        return nodefn.call(git.wrongBranch, workDir, branch);
      }, function() {
        return nodefn.call(git.noStagedChanges, workDir);
      }, function() {
        return nodefn.call(Shell.spawn, 'git', git.commitArgs(workDir, logMessage), superTask);
      }
    ]).then(function(resultArray) {
      var commited;
      commited = resultArray[3];
      superTask.notify.info.normal('committed', commited);
      return callback(null, resultArray);
    }, function(error) {
      if (error === 'missing repo') {
        superTask.notify.info.bad('missing repo', workDir);
        callback(null, {});
        return;
      }
      if (error === 'wrong branch') {
        superTask.notify.info.bad('wrong branch', "" + workDir + " - expects " + branch);
        callback(null, {});
        return;
      }
      if (error === 'nothing staged') {
        superTask.notify.info.normal('nothing staged', "" + workDir);
        callback(null, {});
        return;
      }
      return callback(error);
    });
  },
  pull: function(workDir, origin, branch, superTask, callback) {
    return sequence([
      function() {
        return nodefn.call(git.missingRepo, workDir);
      }, function() {
        return nodefn.call(git.wrongBranch, workDir, branch);
      }, function() {
        return nodefn.call(Shell.spawnAt, {
          directory: workDir
        }, 'git', ['pull', origin, branch], superTask);
      }
    ]).then(function(resultArray) {
      var pulled;
      pulled = resultArray[2];
      console.log('pull result', pulled);
      return callback(null, resultArray);
    }, function(error) {
      if (error === 'missing repo') {
        superTask.notify.info.bad('missing repo', workDir);
        callback(null, {});
        return;
      }
      if (error === 'wrong branch') {
        superTask.notify.info.bad('wrong branch', "" + workDir + " - expects " + branch);
        callback(null, {});
        return;
      }
      return callback(error);
    });
  }
};
