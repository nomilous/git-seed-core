// Generated by CoffeeScript 1.4.0
var Shell, defer, fs, git, mkdirp, nodefn, pipeline, sequence;

Shell = require('./shell');

fs = require('fs');

sequence = require('when/sequence');

pipeline = require('when/pipeline');

nodefn = require('when/node/function');

defer = require('when').defer;

mkdirp = require('fs-extra').mkdirp;

module.exports = git = {
  getConfigItem: function(superTask, repo, configItem, callback) {
    var gitDir;
    gitDir = "" + repo.workDir + "/.git";
    try {
      return Shell.spawn(null, 'git', ["--git-dir=" + gitDir, 'config', '--get', configItem], function(error, result) {
        if (error) {
          return callback(error);
        }
        repo[configItem] = result.stdout.trim();
        return callback(null, repo);
      });
    } catch (error) {
      return callback(error);
    }
  },
  getHEAD: function(superTask, repo, callback) {
    var gitDir;
    gitDir = "" + repo.workDir + "/.git";
    return fs.readFile("" + gitDir + "/HEAD", function(error, data) {
      if (error) {
        return callback(error);
      }
      try {
        repo.HEAD = data.toString().match(/ref: (.*)\n$/)[1];
      } catch (error) {
        return callback(error);
      }
      return callback(null, repo);
    });
  },
  getVersion: function(superTask, repo, ref, callback) {
    var gitDir;
    gitDir = "" + repo.workDir + "/.git";
    return fs.readFile("" + gitDir + "/" + ref, function(error, data) {
      if (error) {
        return callback(error);
      }
      repo.version = data.toString().trim();
      return callback(null, repo);
    });
  },
  getStatus: function(superTask, repo, callback) {
    var gitDir;
    repo.status || (repo.status = {});
    if (repo.status['missing repo']) {
      return callback(null, repo);
    }
    if (repo.status['wrong branch']) {
      return callback(null, repo);
    }
    gitDir = "" + repo.workDir + "/.git";
    return Shell.spawn(null, 'git', ["--git-dir=" + gitDir, "--work-tree=" + repo.workDir, 'status'], function(error, status) {
      if (error) {
        return callback(error);
      }
      if (status.stdout.match(/branch is ahead/)) {
        repo.status['unpushed changes'] = true;
        repo.status.latest = 'unpushed changes';
        repo.status.tenor = 'bad';
        repo.status.detail = status.stdout;
        return callback(null, repo);
      }
      if (status.stdout.match(/nothing to commit \(working directory clean\)/)) {
        repo.status['no changes'] = true;
        repo.status.latest = 'no changes';
        repo.status.tenor = 'normal';
        repo.status.detail = status.stdout;
        return callback(null, repo);
      }
      repo.status['has changes'] = true;
      repo.status.latest = 'has changes';
      repo.status.tenor = 'good';
      repo.status.detail = status.stdout;
      return callback(null, repo);
    });
  },
  checkoutArgs: function(workDir, branch) {
    return ["--git-dir=" + workDir + "/.git", "--work-tree=" + workDir, 'checkout', branch.replace('refs/heads/', '')];
  },
  makeWorkDir: function(superTask, repo, callback) {
    if (Shell.gotDirectory(repo.workDir)) {
      return callback(null, repo);
    }
    return mkdirp(repo.workDir, function(err) {
      if (err != null) {
        superTask.notify.info.bad('mkdirp', "FAILED to create " + repo.workDir);
        return callback(err, null);
      }
      superTask.notify.info.normal('mkdirp', repo.workDir);
      return callback(err, repo);
    });
  },
  ensureWorkDir: function(superTask, repo, callback) {
    if (!Shell.gotDirectory(repo.workDir)) {
      return git.makeWorkDir(superTask, repo, callback);
    }
    return callback(null, repo);
  },
  ensureClone: function(superTask, repo, callback) {
    var args, gitDir;
    gitDir = "" + repo.workDir + "/.git";
    if (!Shell.gotDirectory(gitDir)) {
      superTask.allow_stdio = true;
      args = ['clone', repo['remote.origin.url'], repo.workDir];
      return Shell.spawn(superTask, 'git', args, callback);
    }
    superTask.notify.info.normal('skip', "already cloned " + repo.workDir);
    return callback(null, repo);
  },
  ensureHEAD: function(superTask, repo, callback) {
    return git.getHEAD(superTask, {
      workDir: repo.workDir
    }, function(error, actualRepo) {
      var args;
      if (repo.HEAD !== actualRepo.HEAD) {
        superTask.notify.info.good('checkout', "" + repo.HEAD + " in " + repo.workDir);
        args = git.checkoutArgs(repo.workDir, repo.HEAD);
        return Shell.spawn(superTask, 'git', args, callback);
      }
      return callback(null, repo);
    });
  },
  missingRepo: function(superTask, repo, callback) {
    var gitDir, missing;
    gitDir = "" + repo.workDir + "/.git";
    missing = false;
    if (!Shell.gotDirectory(gitDir)) {
      missing = true;
    }
    repo.status || (repo.status = {});
    repo.status['missing repo'] = missing;
    if (missing) {
      repo.status.latest = 'missing repo';
      repo.status.tenor = 'bad';
    }
    return callback(null, repo);
  },
  wrongBranch: function(superTask, repo, callback) {
    repo.status || (repo.status = {});
    if (repo.status['missing repo']) {
      return callback(null, repo);
    }
    return git.getHEAD(superTask, {
      workDir: repo.workDir
    }, function(error, actualRepo) {
      var wrong;
      wrong = repo.HEAD !== actualRepo.HEAD;
      repo.status || (repo.status = {});
      repo.status['wrong branch'] = wrong;
      if (wrong) {
        repo.status.latest = 'wrong branch';
        repo.status.tenor = 'bad';
        repo.status.detail = "\nexpected " + repo.HEAD + "\nfound " + actualRepo.HEAD + "\n";
      }
      return callback(null, repo);
    });
  },
  status: function(superTask, repo, args, callback) {
    var input;
    input = {
      workDir: repo.workDir,
      HEAD: repo.HEAD
    };
    return pipeline([
      function() {
        return nodefn.call(git.missingRepo, superTask, input);
      }, function(assemble) {
        return nodefn.call(git.wrongBranch, superTask, assemble);
      }, function(assemble) {
        return nodefn.call(git.getStatus, superTask, assemble);
      }
    ]).then(function(assembled) {
      var latest, tenor;
      latest = assembled.status.latest;
      tenor = assembled.status.tenor || 'normal';
      if (latest === 'no changes') {
        superTask.notify.info[tenor]('skip', {
          description: "no changes " + assembled.workDir
        });
      } else {
        superTask.notify.info[tenor](latest, {
          description: assembled.workDir,
          detail: assembled.status.detail
        });
      }
      return callback(null, assembled);
    }, function(error) {
      return callback(error);
    });
  },
  clone: function(superTask, repo, args, callback) {
    return pipeline([
      function() {
        return nodefn.call(git.ensureWorkDir, superTask, repo);
      }, function(assemble) {
        return nodefn.call(git.ensureClone, superTask, repo);
      }, function(assemble) {
        return nodefn.call(git.ensureHEAD, superTask, repo);
      }
    ]).then(function(assembled) {
      return callback(null, assembled);
    }, function(error) {
      return callback(error);
    });
  },
  getStagedChanges: function(superTask, repo, callback) {
    repo.status || (repo.status = {});
    if (repo.status['missing repo']) {
      return callback(null, repo);
    }
    if (repo.status['wrong branch']) {
      return callback(null, repo);
    }
    return Shell.spawn(null, 'git', ["--git-dir=" + repo.workDir + "/.git", "--work-tree=" + repo.workDir, 'diff', '--cached'], function(error, result) {
      repo.status || (repo.status = {});
      repo.status['staged changes'] = result.stdout !== '';
      repo.status.latest = 'staged changes';
      repo.status.tenor = 'normal';
      return callback(error, repo);
    });
  },
  commitArgs: function(workDir, logMessage) {
    return ["--git-dir=" + workDir + "/.git", "--work-tree=" + workDir, 'commit', '-m', logMessage];
  },
  commit: function(superTask, repo, args, callback) {
    return pipeline([
      function() {
        return nodefn.call(git.missingRepo, superTask, repo);
      }, function(assemble) {
        return nodefn.call(git.wrongBranch, superTask, assemble);
      }, function(assemble) {
        return nodefn.call(git.getStagedChanges, superTask, assemble);
      }, function(assemble) {
        return nodefn.call(function(callback) {
          var commitArgs;
          if (!assemble.status['staged changes']) {
            return callback(null, assemble);
          }
          commitArgs = git.commitArgs(repo.workDir, args.message);
          return Shell.spawn(superTask, 'git', commitArgs, function(error, result) {
            if (result.code === 0) {
              superTask.notify.info.good('commit', {
                description: repo.workDir,
                detail: result.stdout
              });
            } else {
              superTask.notify.info.bad('commit failed', {
                description: repo.workDir,
                detail: result.stdout
              });
            }
            return callback(null, assemble);
          });
        });
      }
    ]).then(function(assembled) {
      var latest, tenor;
      latest = assembled.status.latest;
      tenor = assembled.status.tenor || 'normal';
      if (latest === 'staged changes') {
        superTask.notify.info[tenor]('skip', {
          description: "no staged changes " + assembled.workDir
        });
      } else {
        superTask.notify.info[tenor](latest, {
          description: assembled.workDir,
          detail: assembled.status.detail
        });
      }
      return callback(null, assembled);
    }, function(error) {
      return callback(error);
    });
  },
  pull: function(superTask, repo, args, callback) {
    var input;
    input = {
      workDir: repo.workDir,
      HEAD: repo.HEAD
    };
    return pipeline([
      function() {
        return nodefn.call(git.missingRepo, superTask, input);
      }, function(assemble) {
        return nodefn.call(git.wrongBranch, superTask, assemble);
      }, function(assemble) {
        return nodefn.call(git.getVersion, superTask, assemble, input.HEAD);
      }, function(assemble) {
        return nodefn.call(function(callback) {
          repo.status = input.status;
          if (assemble.status['missing repo'] || assemble.status['wrong branch']) {
            return callback(null, repo);
          }
          if (assemble.version !== repo.version) {
            superTask.notify.info.good('pull', {
              description: assemble.workDir
            });
            return Shell.spawnAt(superTask, {
              directory: repo.workDir
            }, 'git', ['pull', repo['remote.origin.url'], repo.HEAD], function(error, result) {
              return callback(null, repo);
            });
          } else {
            superTask.notify.info.normal('skip', {
              description: 'already up-to-date ' + assemble.workDir
            });
            return callback(null, repo);
          }
        });
      }
    ]).then(function(assembled) {
      var latest, tenor;
      latest = assembled.status.latest;
      tenor = assembled.status.tenor || 'normal';
      return callback(null, assembled);
    }, function(error) {
      console.log('ERROR:', error);
      return callback(error);
    });
  }
};
