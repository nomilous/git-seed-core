// Generated by CoffeeScript 1.4.0
var Findit, GitRepo, GitSupport, Shell, nodefn, sequence;

GitSupport = require('./git_support');

Shell = require('./shell');

Findit = require('findit');

sequence = require('when/sequence');

nodefn = require('when/node/function');

GitRepo = (function() {

  GitRepo.manager = function() {
    return 'none';
  };

  GitRepo.search = function(rootRepoDir, Plugin, superTask, callback) {
    var find, found, manager, uniq;
    find = Findit.find(rootRepoDir);
    uniq = {};
    found = [];
    manager = this.manager();
    find.on('directory', function(dir, stat) {
      var match;
      if (match = dir.match(/(.*)\/.git\//)) {
        if (typeof uniq[match[1]] !== 'undefined') {
          return;
        }
        uniq[match[1]] = 1;
        superTask.notify.info.good('found repo', "" + match[1] + "/.git");
        return found.push(match[1]);
      }
    });
    return find.on('end', function() {
      var failed, path, paths, seq, success, tasks;
      seq = 0;
      paths = [];
      tasks = sequence((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = found.length; _i < _len; _i++) {
          path = found[_i];
          paths.unshift(path);
          _results.push(function() {
            return nodefn.call(Plugin.Package.init, paths.pop(), seq++, manager, superTask);
          });
        }
        return _results;
      })());
      return tasks.then(success = function(repos) {
        return callback(null, repos);
      }, failed = function(error) {
        return callback(error);
      });
    });
  };

  GitRepo.init = function(repoDir, seq, manager, superTask, callback) {
    var failed, success, tasks;
    tasks = sequence([
      function() {
        return nodefn.call(GitSupport.getOrigin, repoDir);
      }, function() {
        return nodefn.call(GitSupport.getHeadRef, repoDir);
      }, function() {
        return nodefn.call(GitSupport.getHeadVersion, repoDir);
      }
    ]);
    return tasks.then(success = function(results) {
      return callback(null, {
        root: seq === 0,
        path: repoDir,
        manager: manager,
        origin: results[0],
        branch: results[1],
        ref: results[2]
      });
    }, failed = function(error) {
      return callback(error);
    });
  };

  GitRepo.status = function(repo, args, superTask, callback) {
    if (!Shell.gotDirectory(repo.path + '/.git')) {
      superTask.notify.info.bad('missing repo', repo.path);
      callback(null, {});
      return;
    }
    return GitSupport.getStatus(repo.path, function(error, status) {
      if (status.stdout.match(/branch is ahead/)) {
        superTask.notify.info.bad('unpushed', {
          description: repo.path,
          detail: status.stdout
        });
        callback(null, status);
        return;
      }
      if (status.stdout.match(/nothing to commit \(working directory clean\)/)) {
        superTask.notify.info.good('unchanged', repo.path);
        callback(null, {});
        return;
      }
      superTask.notify.info.good('changed', {
        description: repo.path,
        detail: status.stdout
      });
      return callback(null, status);
    });
  };

  GitRepo.clone = function(repo, args, superTask, callback) {
    return GitSupport.clone(repo.path, repo.origin, repo.branch, superTask, callback);
  };

  GitRepo.commit = function(repo, args, superTask, callback) {
    return GitSupport.commit(repo.path, repo.origin, repo.branch, args.message, superTask, callback);
  };

  GitRepo.install = function(repo, args, superTask, callback) {
    superTask.notify.info.normal('no package manager', '');
    return callback(null, {});
  };

  function GitRepo(properties) {
    var property;
    for (property in properties) {
      this[property] = properties[property];
      if (property === 'ref' && this.root) {
        this[property] = 'ROOT_REPO_REF';
      }
    }
  }

  return GitRepo;

})();

module.exports = GitRepo;
