// Generated by CoffeeScript 1.4.0
var Findit, GitRepo, GitSupport, Shell, w;

require('colors');

console.log('IMPORTANT: catch22 on the root repo having a ref');

console.log('remove colors');

GitSupport = require('./git_support');

Shell = require('./shell');

Findit = require('findit');

w = require('when');

GitRepo = (function() {

  GitRepo.manager = function() {
    return 'none';
  };

  GitRepo.search = function(rootRepoDir, Plugin, masterDefer, callback) {
    var arrayOfGitWorkdirs, find, list;
    arrayOfGitWorkdirs = [];
    list = {};
    find = Findit.find(rootRepoDir);
    find.on('directory', function(dir, stat) {
      var match;
      if (match = dir.match(/(.*)\/.git\//)) {
        if (typeof list[match[1]] !== 'undefined') {
          return;
        }
        masterDefer.notify({
          cli: {
            context: 'good',
            event: 'found repo',
            detail: "" + match[1] + "/.git"
          }
        });
        list[match[1]] = 1;
        return arrayOfGitWorkdirs.push(match[1]);
      }
    });
    return find.on('end', function() {
      var defer, error, packages, path, promises, seq, success, _i, _len;
      seq = 0;
      packages = [];
      promises = [];
      for (_i = 0, _len = arrayOfGitWorkdirs.length; _i < _len; _i++) {
        path = arrayOfGitWorkdirs[_i];
        defer = w.defer();
        promises.push(defer.promise);
        defer.promise.then(success = function(repo) {
          return packages.push(repo);
        }, error = function(reason) {});
        Plugin.Package.init(path, seq++, masterDefer, defer);
      }
      return w.all(promises).then(success = function() {
        return callback(null, packages);
      }, error = function(reason) {
        return callback(reason);
      });
    });
  };

  GitRepo.init = function(repoDir, seq, masterDefer, defer) {
    var branchDefer, originDefer, repo, versionDefer;
    repo = {
      root: seq === 0,
      path: repoDir,
      manager: this.manager()
    };
    originDefer = w.defer();
    branchDefer = w.defer();
    versionDefer = w.defer();
    w.all([originDefer.promise, branchDefer.promise, versionDefer.promise]).then(function() {
      return defer.resolve(repo);
    });
    GitSupport.getOrigin(repoDir, function(error, origin) {
      repo.origin = origin;
      return originDefer.resolve();
    });
    GitSupport.getHeadRef(repoDir, function(error, branch) {
      repo.branch = branch;
      return branchDefer.resolve();
    });
    return GitSupport.getHeadVersion(repoDir, function(error, version) {
      repo.ref = version;
      return versionDefer.resolve();
    });
  };

  function GitRepo(properties) {
    var property;
    for (property in properties) {
      this[property] = properties[property];
      if (property === 'ref' && this.root) {
        this[property] = 'ROOT_REPO_REF';
      }
    }
  }

  GitRepo.prototype.notifyMissing = function(masterDefer) {
    masterDefer.notify({
      cli: {
        context: 'bad',
        event: 'missing repo',
        detail: "" + this.path
      }
    });
    return false;
  };

  GitRepo.prototype.getStatus = function(masterDefer) {
    var _this = this;
    if (!Shell.gotDirectory(this.path + '/.git')) {
      return notifyMissing(masterDefer);
    }
    return GitSupport.getStatus(this.path, function(error, status) {
      var context, detail, event, show;
      show = true;
      if (status.stdout.match(/nothing to commit \(working directory clean\)/)) {
        show = false;
      }
      if (status.stdout.match(/Your branch is ahead/)) {
        show = true;
      }
      if (show) {
        context = 'good';
        event = 'changed';
        detail = _this.path + '\n' + status.stdout;
      } else {
        context = 'good';
        event = 'unchanged';
        detail = _this.path;
      }
      return masterDefer.notify({
        cli: {
          context: context,
          event: event,
          detail: detail
        }
      });
    });
  };

  GitRepo.prototype.clone = function(callback) {
    return GitSupport.clone(this.path, this.origin, this.branch, callback);
  };

  GitRepo.prototype.commit = function(message, callback) {
    return GitSupport.commit(this.path, this.branch, message, callback);
  };

  GitRepo.prototype.pull = function(callback) {
    return GitSupport.pull(this.path, this.origin, this.branch, this.ref, callback);
  };

  GitRepo.prototype.install = function(callback) {
    console.log('(skip)'.red, "plugin did not override GitRepo.install()");
    return callback(null, null);
  };

  return GitRepo;

})();

module.exports = GitRepo;
