// Generated by CoffeeScript 1.4.0
var Findit, GitRepo, GitSupport, Shell, nodefn, pipeline, sequence;

GitSupport = require('./git_support');

Shell = require('./shell');

Findit = require('findit');

sequence = require('when/sequence');

pipeline = require('when/pipeline');

nodefn = require('when/node/function');

GitRepo = (function() {

  GitRepo.manager = function() {
    return 'none';
  };

  GitRepo.search = function(rootRepoDir, Plugin, superTask, callback) {
    var find, found, manager, uniq;
    find = Findit.find(rootRepoDir);
    uniq = {};
    found = [];
    manager = this.manager();
    find.on('directory', function(dir, stat) {
      var match;
      if (match = dir.match(/(.*)\/.git\//)) {
        if (typeof uniq[match[1]] !== 'undefined') {
          return;
        }
        uniq[match[1]] = 1;
        superTask.notify.info.normal('found repo', "" + match[1] + "/.git");
        return found.push(match[1]);
      }
    });
    return find.on('end', function() {
      var failed, path, paths, seq, success, tasks;
      seq = 0;
      paths = [];
      tasks = sequence((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = found.length; _i < _len; _i++) {
          path = found[_i];
          paths.unshift(path);
          _results.push(function() {
            return nodefn.call(Plugin.Package.init, paths.pop(), seq++, manager, superTask);
          });
        }
        return _results;
      })());
      return tasks.then(success = function(repos) {
        return callback(null, repos);
      }, failed = function(error) {
        return callback(error);
      });
    });
  };

  GitRepo.init = function(workDir, seq, manager, superTask, callback) {
    var failed, input, success, tasks;
    input = {
      root: seq === 0,
      workDir: workDir,
      packageManager: manager
    };
    tasks = pipeline([
      function() {
        return nodefn.call(GitSupport.getConfigItem, input, 'remote.origin.url');
      }, function(repo) {
        return nodefn.call(GitSupport.getHEAD, repo);
      }, function(repo) {
        return nodefn.call(GitSupport.getVersion, repo, repo.HEAD);
      }
    ]);
    return tasks.then(success = function(repoo) {
      return callback(null, repoo);
    }, failed = function(error) {
      return callback(error);
    });
  };

  GitRepo.status = function(repo, args, superTask, callback) {
    return GitSupport.status(repo.path, repo.origin, repo.branch, superTask, callback);
  };

  GitRepo.clone = function(repo, args, superTask, callback) {
    return GitSupport.clone(repo.path, repo.origin, repo.branch, superTask, callback);
  };

  GitRepo.commit = function(repo, args, superTask, callback) {
    return GitSupport.commit(repo.path, repo.origin, repo.branch, args.message, superTask, callback);
  };

  GitRepo.pull = function(repo, args, superTask, callback) {
    return GitSupport.pull(repo.path, repo.origin, repo.branch, superTask, callback);
  };

  GitRepo.install = function(repo, args, superTask, callback) {
    superTask.notify.info.normal('no package manager', '');
    return callback(null, {});
  };

  function GitRepo(properties) {
    var property;
    for (property in properties) {
      this[property] = properties[property];
      if (property === 'ref' && this.root) {
        this[property] = 'ROOT_REPO_REF';
      }
    }
  }

  return GitRepo;

})();

module.exports = GitRepo;
